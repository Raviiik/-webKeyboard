<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Sanskrit_Keybard</title>
  <style>
   @font-face {
  font-family: "Andika";
  src: url("./fonts/Andika-Regular.woff2") format("woff2");
  font-weight: normal;
  font-style: normal;
  font-display: swap;
}

body {
  font-family: "Andika", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
}


    :root {
      --kbd-width: 360px;
      --gap: 8px;
      --key-height: 46px;
    }

    html, body {
      height: 100%;
      margin: 0;
      font-family: 'Andika';
      background: #f5f7fa;
      color: #111;
    }
    * { font-family: 'Andika' }

    .app { display: flex; height: 100vh; gap: 12px; padding: 12px; box-sizing: border-box; }
    .editor { flex: 1; display: flex; flex-direction: column; }

    textarea#mainText {
      flex: 1;
      resize: none;
      padding: 14px;
      font-size: 18px;
      line-height: 1.5;
      letter-spacing: 0.1px;
      border-radius: 12px;
      border: 1px solid #A2A2A2;
      box-sizing: border-box;
      background: #fff;
      -webkit-user-select: text;
      user-select: text;
      overflow: auto;
      min-height: 967px;
    }

    .keyboard {
      width: var(--kbd-width);
      min-width: 170px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      background: #ffffff;
      border-radius: 12px;
      padding: 10px;
      box-shadow: 0 6px 18px rgba(20,30,50,0.06);
      position: relative; /* для абсолютной всплывашки */
    }

    .controls { display: flex; flex-direction: column; gap: 8px; }
    .row-controls { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    .btn { padding: 6px 8px; border-radius: 10px; border: 1px solid #999; background: #f0f0f0; cursor: pointer; font-size: 14px; }
    .btn.secondary { background: #fff; }
    .btn.toggle-active { background: #e8fff0; border-color: #58b16a; }
    .status { font-size: 13px; color: inherit; }
    .small { font-size: 12px; opacity: .85; }


    .rows {
      display: flex;
      flex-direction: column;
      gap: 10px;
      overflow: auto;
      max-height: 84vh;
      padding-right: 6px;
      touch-action: pan-y;
      -webkit-overflow-scrolling: touch;
    }

    .row { display: grid; gap: var(--gap); }
    .key {
      height: var(--key-height);
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 10px;
      border: 1px solid #d0d6df;
      background: #fbfdff;
      cursor: pointer;
      user-select: none;
      position: relative;
      padding: 8px 10px;
      font-size: 20px;
      box-shadow: 0 1px 0 rgba(0,0,0,0.02) inset;
      transition: transform .08s ease, background .12s ease;
      touch-action: manipulation;
      color: #111;
    }
    .key:active { transform: translateY(1px) scale(.99); }
    .key:hover { background: #eef5ff; }
    .key.empty {
      background: transparent; border: none; cursor: default; box-shadow: none; height: var(--key-height);
    }

    .btn {
      transition: transform 0.15s ease;
    }
    .btn:hover {
      transform: scale(1.06);
    }
    .btn:active {
      transform: scale(0.94);
    }

    .key:focus,
    .btn:focus {
      outline: none;
      box-shadow: none;
    }
    .key, .btn {
      -webkit-tap-highlight-color: transparent;
      outline: none;
      box-shadow: none;
    }

    .theme-toggle {
      width: 90px;
      height: 38px;
      border-radius: 19px;
      background: #ddd;
      position: relative;
      cursor: pointer;
      display: flex;
      align-items: center;
      padding: 4px;
      box-sizing: border-box;
      transition: background 0.3s ease;
    }

    .theme-toggle .thumb {
      width: 30px;
      height: 30px;
      background: white;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      position: absolute;
      left: 4px;
      top: 4px;
      transition: left 0.3s ease;
      user-select: none;
      touch-action: none;
      font-size: 16px;
    }

    .theme-toggle.night {
      background: #333;
    }
    .theme-toggle.night .thumb {
      left: 56px;
    }

    .legend { display: flex; justify-content: space-between; align-items: center; gap: 10px; flex-wrap: wrap; }

    .smallBtn {
      padding: 3px 6px;
      font-size: 12px;
      min-width: 40px;
      height: 60px;
    }

    .jumpBtn {
      height: 40px !important;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    @media (max-width: 900px) {
      .app { flex-direction: column; padding: 10px; gap: 10px; }
      .keyboard {
        position: fixed;
        bottom: 0; left: 0; right: 0;
        width: auto;
        border-radius: 14px 14px 0 0;
        z-index: 9999;
        box-shadow: 0 -2px 18px rgba(20,30,50,0.18);
        max-height: 48vh;
      }


      .rows {
        max-height: 23vh;
        touch-action: pan-y;
        -webkit-overflow-scrolling: touch;
      }

      textarea#mainText { font-size: 19px; min-height: 40vh; }
      .editor { order: 1; }
    }

    body.dark { background: #000; color: #fff; }
    body.dark .app { color: #fff; }
    body.dark textarea#mainText { background: #000; color: #fff; border-color: #333; }
    body.dark .keyboard { background: #000; box-shadow: none; border: 1px solid #222; }
    body.dark .rows { scrollbar-color: #666 #000; }
    body.dark .key { background: #111; color: #fff; border-color: #333; }
    body.dark .key:hover { background: #161616; }
    body.dark .btn { background: #111; color: #fff; border-color: #444; }
    body.dark .btn.toggle-active { background: #143016; border-color: #2b7a3a; }
    body.dark .small, body.dark .status { color: #fff; opacity: .9; }

    .icon-btn {
      width: clamp(40px, 9vw, var(--key-height));
      height: clamp(40px, 9vw, var(--key-height));
      min-width: 44px;
      min-height: 44px;
      padding: 6px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      box-sizing: border-box;
      margin-left: 6px;
      border-radius: 10px;
    }

    .icon-btn img.icon-img {
      width: 70%;
      height: 70%;
      max-width: 22px;
      max-height: 22px;
      object-fit: contain;
      pointer-events: none;
      transition: filter .15s ease, opacity .15s ease, transform .12s ease;
      display: inline-block;
    }

    .icon-btn svg.icon-fallback { display:none; width:70%; height:70%; max-width:22px; max-height:22px; }

    body.dark .icon-btn img.icon-img { filter: invert(1) grayscale(0); }

    #capsBtn.caps-dim { background: #e9e9e9; border-color: #cfcfcf; }
    #capsBtn.caps-green { background: #58b16a; border-color: #3c9a4a; color: #fff; }
    body.dark #capsBtn.caps-dim { background: #bfbfbf; border-color: #444; }
    body.dark #capsBtn.caps-green { background: #2b7a3a; border-color: #1f5b2a; color: #fff; }

    #capsBtn.caps-dim img.icon-img { opacity: 0.65; transform: scale(0.98); }
    #capsBtn.caps-green img.icon-img { opacity: 1; transform: scale(1); }

    @media (max-width: 420px) {
      .icon-btn { padding: 4px; }
      .icon-btn img.icon-img, .icon-btn svg.icon-fallback { max-width: 18px; max-height: 18px; }
    }


#settingsBtn .icon-img {
  width: 37px !important;
  height: 45px !important;
  max-width: none !important;
  max-height: none !important;
  display: block;
  object-fit: contain;
    object-fit: contain;
  transform: translateY(2.7px);
   transform: translateX(-1.px);
}

#copyBtn .icon-img {
  width: 21px !important;
  height: 28px !important;
  max-width: none !important;
  max-height: none !important;
  display: block;
  object-fit: contain;
}
#backspaceBtn .icon-img {
  width: 30px !important;
  height: 26px !important;
  max-width: none !important;
  max-height: none !important;
  display: block;
  object-fit: contain;
  transform: translateX(-0.3px);
}
#spaceBtn {
  min-width: 70px !important;
  width: 98px !important;
}
#spaceBtn .icon-img {
  width: 28px !important;
  height: 26px !important;
  max-width: none !important;
  max-height: none !important;
  display: block;
  object-fit: contain;
  transform: translateY(3px);
}
#capsBtn .icon-img {
  transform: translateX(0.6px);
}
    .theme-toggle {
  outline: none;          
  box-shadow: none;       
  -webkit-tap-highlight-color: transparent; 
}

.theme-toggle:focus,
.theme-toggle:active {
  outline: none;
  box-shadow: none;
  background-color: inherit; 
}


#settingsPopup {
  position: absolute;
  top: 52px;
  left: 10px;
  background: #fff;
  color: #111;
  border: 1px solid #ddd;
  padding: 8px;
  border-radius: 14px;
  box-shadow: 0 8px 24px rgba(10,20,40,0.12);
  z-index: 999;
  min-width: 180px;
  max-width: 320px;
}
#settingsPopup.hidden { display: none; }
#settingsPopup h4 { margin: 6px 0 6px 0; font-size: 13px; }
#settingsPopup select {
  width: 100%;
  margin-bottom: 6px;
  padding: 6px 8px;
  box-sizing: border-box;
  border-radius: 8px;
  border: 1px solid #ddd;
  font-size: 13px;
}
#settingsPopup .note { font-size: 12px; opacity: .8; margin-top:4px; }


@media (max-width: 420px) {
  #settingsPopup {
    left: 12px;
    right: 12px;
    top: 54px;
    min-width: unset;
    width: calc(100% - 24px);
    padding: 8px;
    border-radius: 12px;
  }
}

body.dark #settingsPopup { background: #0b0b0b; color: #fff; border-color: #222; }
  </style>
</head>
<body>
  <div class="app">
    <div class="editor">
      <textarea id="mainText" placeholder="Write here..." spellcheck="false" autocapitalize="off" autocomplete="off" autocorrect="off"></textarea>
      <div style="padding-top:8px; display:flex; justify-content:space-between; align-items:center;">
        <div class="small"></div>
        <div class="small"></div>
      </div>
    </div>

    <div class="keyboard" id="keyboard" aria-live="polite">
      <div class="controls">

        <div class="legend">
          <div style="display:flex;align-items:center;gap:10px">
            <label style="display:flex;align-items:center;gap:6px">
              <input type="checkbox" id="allowPhysical"> lock system keyboard
            </label>

           
            <button class="btn icon-btn" id="settingsBtn" title="Настройки" aria-label="Настройки">
              <img class="icon-img" src="./settings.svg" alt="settings" decoding="async" draggable="false"
                   onload="this.style.display='inline-block';" onerror="this.style.display='none'">
              <svg class="icon-fallback" viewBox="0 0 24 24" fill="none" aria-hidden="true" xmlns="http://www.w3.org/2000/svg">
                <circle cx="12" cy="12" r="3" stroke="currentColor" stroke-width="1.6"/>
                <path d="M19.4 15a1.65 1.65 0 00.33 1.82l.06.06a2 2 0 01-2.83 2.83l-.06-.06a1.65 1.65 0 00-1.82-.33 1.65 1.65 0 00-1 1.51V21a2 2 0 01-4 0v-.09a1.65 1.65 0 00-1-1.51 1.65 1.65 0 00-1.82.33l-.06.06a2 2 0 01-2.83-2.83l.06-.06c.46-.46.6-1.15.33-1.82a1.65 1.65 0 00-1.51-1H3a2 2 0 010-4h.09c.7 0 1.31-.39 1.51-1a1.65 1.65 0 00-.33-1.82l-.06-.06a2 2 0 012.83-2.83l.06.06c.46.46 1.15.6 1.82.33h.09c.61-.2 1-.81 1-1.51V3a2 2 0 014 0v.09c0 .7.39 1.31 1 1.51h.09c.67.27 1.36.13 1.82-.33l.06-.06a2 2 0 012.83 2.83l-.06.06c-.46.46-.6 1.15-.33 1.82v.09c.2.61.81 1 1.51 1H21a2 2 0 010 4h-.09c-.7 0-1.31.39-1.51 1z"/>
              </svg>
            </button>

            <button class="btn icon-btn" id="copyBtn" title="Copy all" aria-label="Copy all">
              <img class="icon-img" src="./copy.svg" alt="copy" decoding="async" draggable="false"
                   onload="this.style.display='inline-block'; this.parentNode.querySelector('.icon-fallback-copy').style.display='none';"
                   onerror="this.style.display='none'; this.parentNode.querySelector('.icon-fallback-copy').style.display='inline-block'">
              <svg class="icon-fallback icon-fallback-copy" viewBox="0 0 24 24" fill="none" aria-hidden="true" xmlns="http://www.w3.org/2000/svg">
                <rect x="6" y="6" width="12" height="12" rx="2" stroke="currentColor" stroke-width="1.8"/>
                <rect x="4" y="4" width="12" height="12" rx="2" stroke="currentColor" stroke-width="1.2"/>
              </svg>
            </button>

            <button class="btn icon-btn" id="backspaceBtn" title="Backspace / delete" aria-label="Backspace">
              <img class="icon-img" src="./backspace.svg" style="width: 1000px; height: 100px;" alt="backspace" decoding="async" draggable="false"
                   onload="this.style.display='inline-block'; this.parentNode.querySelector('.icon-fallback-back').style.display='none';"
                   onerror="this.style.display='none'; this.parentNode.querySelector('.icon-fallback-back').style.display='inline-block'">
              <svg class="icon-fallback icon-fallback-back" viewBox="0 0 24 24" fill="none" aria-hidden="true" xmlns="http://www.w3.org/2000/svg">
                <path d="M20 6H9L4 12l5 6h11V6z" stroke="currentColor" stroke-width="1.6" fill="none"/>
                <path d="M15 9l-4 4M11 9l4 4" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/>
              </svg>
            </button>

            <button class="btn icon-btn" id="capsBtn" title="Caps (click = one-time, dblclick = lock)" aria-label="Caps">
              <img class="icon-img" id="capsIcon" src="./caps.svg" alt="caps" decoding="async" draggable="false"
                   onload="this.style.display='inline-block'; this.parentNode.querySelector('.icon-fallback-caps').style.display='none';"
                   onerror="this.style.display='none'; this.parentNode.querySelector('.icon-fallback-caps').style.display='inline-block'">
              <svg class="icon-fallback icon-fallback-caps" viewBox="0 0 24 24" fill="none" aria-hidden="true" xmlns="http://www.w3.org/2000/svg">
                <path d="M12 5l7 7h-4v6h-6v-6H5l7-7z" stroke="currentColor" stroke-width="1.6" fill="none"/>
              </svg>
            </button>

          </div>


<div id="settingsPopup" class="hidden" role="dialog" aria-hidden="true" aria-label="Настройки клавиатуры">
  <h4>Язык раскладки</h4>
  <select id="langSelect" aria-label="Выбор языка">
    <option value="default">Default</option>
    <option value="ru">Русская раскладка </option>
    <option value="en">English</option>
    <option value="sa">Sanscrit / Devanagari</option>
  </select>

<div class="note" style="margin-top:6px">Настройки сохраняются в localStorage.</div>
</div>


<div style="display:flex; gap:6px; align-items:center; flex-wrap:wrap;">

  <div class="theme-toggle" id="themeToggle">
    <div class="thumb" id="themeThumb">☀️</div>
  </div>

  <button class="btn jumpBtn smallBtn" data-row="1" title="Scroll to row 5">Ѳѳ</button>
  <button class="btn jumpBtn smallBtn" data-row="14" title="Scroll to row 7">Аа</button>
  <button class="btn jumpBtn smallBtn" data-row="27" title="Scroll to row 9">√≈</button>
  <button class="btn icon-btn" id="spaceBtn" title="Space" aria-label="Space">
    <img class="icon-img" src="./space.svg" alt="space" decoding="async" draggable="false"
         onload="this.style.display='inline-block'; this.parentNode.querySelector('.icon-fallback-space').style.display='none';"
         onerror="this.style.display='none'; this.parentNode.querySelector('.icon-fallback-space').style.display='inline-block'">
    <svg class="icon-fallback icon-fallback-space" viewBox="0 0 24 24" fill="none" aria-hidden="true" xmlns="http://www.w3.org/2000/svg">
      <rect x="3" y="10" width="18" height="4" rx="2" stroke="currentColor" stroke-width="1.6" fill="none"/>
    </svg>
  </button>

</div>

        </div>

        <div class="row-controls">
          <div class="status" id="capsStatus"></div>
          <div class="status small" id="colsStatus"></div>
        </div>

      </div>

      <div class="rows" id="rowsContainer"></div>
    </div>
  </div>

  <script>

(function ensureIconFallbacks() {
  const iconButtons = document.querySelectorAll('.icon-btn');
  iconButtons.forEach(btn => {
    const img = btn.querySelector('img.icon-img');
    const fallback = btn.querySelector('svg.icon-fallback');
    if (!img) {
      if (fallback) fallback.style.display = 'inline-block';
      return;
    }

    if (img.complete && img.naturalWidth > 0) {
      img.style.display = 'inline-block';
      if (fallback) fallback.style.display = 'none';
    } else if (img.complete && img.naturalWidth === 0) {
      img.style.display = 'none';
      if (fallback) fallback.style.display = 'inline-block';
    } else {

      img.addEventListener('load', () => {
        img.style.display = 'inline-block';
        if (fallback) fallback.style.display = 'none';
      });
      img.addEventListener('error', () => {
        img.style.display = 'none';
        if (fallback) fallback.style.display = 'inline-block';
      });
    }
  });
})();
</script>

  <script>

(function () {

  function safeLogError(err) {
    console.error('Webkbd error:', err);
  }

  window.addEventListener('error', function (ev) {
    try {
      safeLogError(ev.error || ev.message || ev);
    } catch (e) { console.error(e); }

    try { if (typeof safeRender === 'function') safeRender(); } catch (e) {}
  });

  window.addEventListener('unhandledrejection', function (ev) {
    try {
      safeLogError(ev.reason);
    } catch (e) {}
    try { if (typeof safeRender === 'function') safeRender(); } catch (e) {}
  });


  function addPointerListeners(target, type, handler, options) {
    options = options || {};

    // Выберем подходящую стратегию в зависимости от возможностей платформы
    const supportsPointer = typeof window.PointerEvent !== 'undefined';
    const supportsTouch = 'ontouchstart' in window;

    const map = (function() {
      // Важно: для быстрого отклика заменяем 'click' на эквивалент DOWN-события
      if (supportsPointer) {
        return {
          down: ['pointerdown'],
          move: ['pointermove'],
          up:   ['pointerup','pointercancel'],
          click:['pointerdown'] // мгновенный отклик на pointerdown
        };
      } else if (supportsTouch) {
        return {
          down: ['touchstart'],
          move: ['touchmove'],
          up:   ['touchend','touchcancel'],
          click:['touchstart'] // мгновенный отклик на touchstart
        };
      } else {
        return {
          down: ['mousedown'],
          move: ['mousemove'],
          up:   ['mouseup'],
          click:['mousedown'] // мгновенный отклик на mousedown
        };
      }
    })();

    const evNames = map[type] || [type];

    function wrapper(ev) {
      try {
        // Обработаем touch как раньше — берем первый touch
        if (ev && ev.type && ev.type.indexOf('touch') === 0 && ev.changedTouches && ev.changedTouches.length) {
          const t = ev.changedTouches[0];
          const synth = {
            originalEvent: ev,
            type: ev.type,
            clientX: t.clientX,
            clientY: t.clientY,
            pointerType: 'touch',
            preventDefault: function(){ try { ev.preventDefault(); } catch(e){} }
          };
          handler.call(this, synth, ev);
        } else {
          handler.call(this, ev, ev);
        }
      } catch (err) {
        try { handler.call(this, ev, ev); } catch(e){}
      }
    }

    evNames.forEach(name => {
      try {
        target.addEventListener(name, wrapper, options);
      } catch (e) {
        try { target.addEventListener(name, wrapper, !!options.capture); } catch (e2) {}
      }
    });
  }

  const KEYS_DEF = [
    ['а','ā','и','ӣ','у','ӯ'],
    ['рь','рь̄ ','љ','љ̄ '],
    ['ԑ','о','әı','ɔү'],
    ['⦂','ᵒ'],
    ['к','к᷉ ','г','г᷉ ','ӈ'],
    ['ч','ч᷉ ','џ','џ᷉ ','њ'],
    ['ԏ','ԏ᷉ ','ԃ','ԃ᷉ ','ԋ'],
    ['т','т᷉ ','д','д᷉ ','н'],
    ['п','п᷉ ','б','б᷉ ','м'],
    ['й','р','л','в'],
    ['щ','ш','с','х'],
    ['•','‿','⁀','ɐ'],
    ['ԑ̆ ','о̆ '],

    ['а','б','в','г','е','ё'],
    ['ж','з','і','и','ѵ','к'],
    ['л','м','н','о','п','р'],
    ['с','т','у','ф','ѳ','х'],
    ['ц','ч','ш','щ','ъ','ы'],
    ['ь','э','ю','я','ѣ'],
    ['!',',','.','…',':',';'],

    ['„','"','«','»','‹','›'],
    ['-','—','_','(',')'],
    ['1','2','3','4','5','6'],
    ['7','8','9','0'],

    ['➀','➁','➂','➃','➄','➅'],
    ['➆','`','°','√','*','^'],
    ['+','=','≠','≥','±'],
    ['~','≈','|','/'],
    ['[',']','{','}','<','>'],
    ['←','→','↓','↑','↙','↗']
  ];

  const CAPS_MAP = new Map([
    ['а','А'], ['ā','Ā'], ['и','И'], ['ӣ','Ӣ'], ['у','У'], ['ӯ','Ӯ'],
    ['рь','РЬ'], ['рь̄ ','РЬ̄ '], ['љ','Љ'], ['љ̄','Љ̄'],
    ['ԑ','Ԑ'], ['о','О'], ['⦂','⦂'], ['ә','Ә'], ['ɔ','Ɔ'], ['ᵒ','ᵒ'],
    ['к','К'], ['к᷉','К᷉'], ['г','Г'], ['г᷉','Г᷉'], ['ӈ','Ӈ'],
    ['ч','Ч'], ['ч᷉','Ч᷉'], ['џ','Џ'], ['џ᷉','Џ᷉'], ['њ','Њ'],
    ['ԏ','Ԏ'], ['ԏ᷉','Ԏ᷉'], ['ԃ','Ԃ'], ['ԃ᷉','Ԃ᷉'], ['ԋ','Ԋ'],
    ['т','Т'], ['т᷉','Т᷉'], ['д','Д'], ['д᷉','Д᷉'], ['н','Н'],
    ['п','П'], ['п᷉','П᷉'], ['б','Б'], ['б᷉','Б᷉'], ['м','М'],
    ['й','Й'], ['р','Р'], ['л','Л'], ['в','В'],
    ['щ','Щ'], ['ш','Ш'], ['с','С'], ['х','Х'], ['ԉ','Ԉ'],
    ['а','А'], ['б','Б'], ['в','В'], ['г','Г'], ['д','Д'], ['е','Е'], ['ё','Ё'],
    ['ж','Ж'], ['з','З'], ['і','І'], ['и','И'], ['ѵ','Ѵ'], ['к','К'], ['л','Л'],
    ['м','М'], ['н','Н'], ['о','О'], ['п','П'], ['р','Р'], ['с','С'], ['т','Т'],
    ['у','У'], ['ф','Ф'], ['ѳ','Ѳ'], ['х','Х'], ['ц','Ц'], ['ч','Ч'], ['ш','Ш'],
    ['щ','Щ'], ['ъ','Ъ'], ['ы','Ы'], ['ь','Ь'], ['э','Э'], ['ю','Ю'], ['я','Я'],
    ['ѣ','Ѣ'],
    ['a','A'], ['b','B'], ['c','C'], ['d','D'], ['e','E'], ['f','F'], ['g','G'], ['h','H'], ['i','I'], ['j','J'],
    ['k','K'], ['l','L'], ['m','M'], ['n','N'], ['o','O'], ['p','P'], ['q','Q'], ['r','R'], ['s','S'], ['t','T'],
    ['u','U'], ['v','V'], ['w','W'], ['x','X'], ['y','Y'], ['z','Z']
  ]);

  function applyCaps(text) {
    if (!text) return text;
    if (!capsOn) return text;
    let res = String(text).normalize('NFC');
    const entries = Array.from(CAPS_MAP.entries()).sort((a, b) => b[0].length - a[0].length);
    for (const [k, v] of entries) {
      if (!k) continue;
      if (res.indexOf(k) === -1) continue;
      res = res.split(k).join(v);
    }
    return res;
  }

  const STORAGE_ALLOW = 'webkbd_allow_v5';
  const STORAGE_COLS  = 'webkbd_cols_v3';
  const STORAGE_CAPS  = 'webkbd_caps_v2';
  const STORAGE_THEME = 'webkbd_theme_v1';
  const STORAGE_FONT  = 'webkbd_font_v1';
  const STORAGE_LANG  = 'webkbd_lang_v1';

  const keyboardEl     = document.getElementById('keyboard') || document.querySelector('.keyboard') || document.body;
  const allowPhysical  = document.getElementById('allowPhysical');
  const mainText       = document.getElementById('mainText');
  const copyBtn        = document.getElementById('copyBtn');
  const backspaceBtn   = document.getElementById('backspaceBtn');
  const spaceBtn       = document.getElementById('spaceBtn');
  const capsBtn        = document.getElementById('capsBtn');
  const themeToggle    = document.getElementById('themeToggle');
  const themeThumb     = document.getElementById('themeThumb');

  let rowsContainer  = document.getElementById('rowsContainer');
  if (!rowsContainer) {
    try {
      rowsContainer = document.createElement('div');
      rowsContainer.id = 'rowsContainer';
      rowsContainer.className = 'rows';

      const controlsEl = keyboardEl.querySelector ? keyboardEl.querySelector('.controls') : null;
      if (controlsEl && controlsEl.parentNode) {
        controlsEl.parentNode.insertBefore(rowsContainer, controlsEl.nextSibling);
      } else {
        keyboardEl.appendChild(rowsContainer);
      }
    } catch (e) {
      console.error('Не удалось создать rowsContainer автоматически', e);
    }
  }

  let maxCols = 6;

  let capsState = 0;
  let capsOn  = false;
  let darkOn  = false;

  let currentLayout = null;


  function applyTheme() {
    try {
      document.body.classList.toggle('dark', !!darkOn);
      if (themeToggle) themeToggle.classList.toggle('night', !!darkOn);
      if (themeThumb) themeThumb.textContent = darkOn ? "🌙" : "☀️";
    } catch (e) {
      console.error('applyTheme error', e);
    }
  }

  function saveAll() {
    try {
      if (allowPhysical) localStorage.setItem(STORAGE_ALLOW, JSON.stringify(!!allowPhysical.checked));
      localStorage.setItem(STORAGE_CAPS, JSON.stringify(Number(capsState)));
      localStorage.setItem(STORAGE_THEME, JSON.stringify(!!darkOn));
    } catch (e) {}
  }

  function loadAll() {
    try {
      const a = JSON.parse(localStorage.getItem(STORAGE_ALLOW));
      if (typeof a === 'boolean' && allowPhysical) allowPhysical.checked = a;
    } catch (e) {}
    try {
      const cap = JSON.parse(localStorage.getItem(STORAGE_CAPS));
      if (typeof cap === 'number') {
        capsState = cap;
      } else if (typeof cap === 'string' && cap.length > 0 && !isNaN(Number(cap))) {
        capsState = Number(cap);
      } else {
        capsState = 0;
      }
    } catch (e) { capsState = 0; }
    capsOn = (capsState === 1 || capsState === 2);
    try {
      const th = JSON.parse(localStorage.getItem(STORAGE_THEME));
      if (typeof th === 'boolean') darkOn = th;
    } catch (e) { darkOn = false; }
    updateCapsUI();
    applyTheme();
  }

  function updateBottomPadding() {
    try {
      const h = keyboardEl.getBoundingClientRect().height || 0;
      document.body.style.paddingBottom = (h + 10) + 'px';
    } catch (e) {}
  }
  try {
    const ro = new ResizeObserver(updateBottomPadding);
    if (keyboardEl && ro) ro.observe(keyboardEl);
    window.addEventListener('orientationchange', () => setTimeout(updateBottomPadding, 200));
    window.addEventListener('resize', () => setTimeout(updateBottomPadding, 100));
  } catch (e) {}

  function buildRows(defRows, cols) {
    const out = [];
    try {
      defRows.forEach(row => {
        if (!Array.isArray(row)) return;
        if (row.length <= cols) {
          out.push(row.slice());
        } else {
          for (let i = 0; i < row.length; i += cols) {
            out.push(row.slice(i, i + cols));
          }
        }
      });
    } catch (e) {
      console.error('buildRows error', e);
    }
    return out;
  }

  function displayTextForKey(originalVal) {
    return applyCaps(originalVal);
  }

  function setSelectionSafe(ta, start, end){
    try { if (typeof ta.focus === 'function') ta.focus(); } catch(e){}
    try {
      if (typeof ta.setSelectionRange === 'function') {
        ta.setSelectionRange(start, end);
      } else if (ta.createTextRange) {
        const range = ta.createTextRange();
        range.collapse(true);
        range.moveEnd('character', end);
        range.moveStart('character', start);
        range.select();
      }
    } catch (e) {}
  }

  function smoothScrollTo(el, top){
    try { if (el.scrollTo) el.scrollTo({ top: top, behavior: 'smooth' }); else el.scrollTop = top; } catch(e){ el.scrollTop = top; }
  }

  function render() {
  try {
    if (!rowsContainer) {
      console.warn('rowsContainer is missing in render(), attempting to recreate.');
      rowsContainer = document.getElementById('rowsContainer');
      if (!rowsContainer && keyboardEl) {
        rowsContainer = document.createElement('div');
        rowsContainer.id = 'rowsContainer';
        rowsContainer.className = 'rows';
        keyboardEl.appendChild(rowsContainer);
      }
      if (!rowsContainer) return;
    }

    while (rowsContainer.firstChild) rowsContainer.removeChild(rowsContainer.firstChild);


    const rows = buildRows(currentLayout || KEYS_DEF, maxCols);
    rows.forEach((rowArr, rowIndex) => {
      try {
        const rowEl = document.createElement('div');
        rowEl.className = 'row';
        rowEl.style.gridTemplateColumns = 'repeat(' + maxCols + ', 1fr)';

        if (!Array.isArray(rowArr) || rowArr.length === 0) {
          const emptyBtn = document.createElement('div');
          emptyBtn.className = 'key empty';
          rowEl.appendChild(emptyBtn);
        } else {
          rowArr.forEach(val => {
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'key';

            const rawVal = String(val || '').normalize('NFC');
            const storedVal = rawVal.trim();

            btn.dataset.value = storedVal;
            btn.textContent = displayTextForKey(storedVal);

            addPointerListeners(btn, 'click', function (ev) {
              try {
                insertAtCursor(storedVal);
              } catch (e) { console.error('insertAtCursor failed', e); }
            }, { passive: true });

            rowEl.appendChild(btn);
          });
        }
        rowsContainer.appendChild(rowEl);
      } catch (eRow) {
        console.error('Ошибка рендера строки', rowIndex, eRow);
      }
    });

    updateBottomPadding();
  } catch (e) {
    console.error('render fatal error', e);
  }
}


  window.safeRender = function () {
    try { render(); } catch (e) { console.error('safeRender error', e); }
  };

  (function tryRenderRetry() {
    let attempts = 0;
    const maxAttempts = 10;
    const id = setInterval(() => {
      try {
        attempts++;
        if (rowsContainer && rowsContainer.children.length > 0) {
          clearInterval(id);
          return;
        }
        render();
        if (rowsContainer && rowsContainer.children.length > 0) {
          clearInterval(id);
          return;
        }
        if (attempts >= maxAttempts) {
          clearInterval(id);
          setTimeout(() => { try { render(); } catch (e) {} }, 1200);
        }
      } catch (e) {
        if (attempts >= maxAttempts) clearInterval(id);
      }
    }, 200);
  })();

  function insertAtCursor(textRaw) {
    try {
      const text = applyCaps(textRaw);
      const ta = mainText;
      const prohibit = !!(allowPhysical && allowPhysical.checked);
      if (!ta) return;
      if (prohibit) ta.readOnly = false;
      const start = (typeof ta.selectionStart === 'number') ? ta.selectionStart : ta.value.length;
      const end = (typeof ta.selectionEnd === 'number') ? ta.selectionEnd : start;
      ta.value = ta.value.substring(0, start) + text + ta.value.substring(end);
      const newPos = start + text.length;

      setSelectionSafe(ta, newPos, newPos);
      if (prohibit) ta.readOnly = true;

      if (capsState === 1) {
        capsState = 0;
        capsOn = false;
        updateCapsUI();
        saveAll();
      }

      ta.dispatchEvent(new Event('input', { bubbles: true }));
      ta.dispatchEvent(new Event('change', { bubbles: true }));
    } catch (e) { console.error('insertAtCursor error', e); }
  }

  function updateCapsUI() {
    try {
      if (!capsBtn) return;
      capsBtn.classList.remove('caps-dim', 'caps-green');
      if (capsState === 1) capsBtn.classList.add('caps-dim');
      if (capsState === 2) capsBtn.classList.add('caps-green');
      capsOn = (capsState !== 0);

      const keyButtons = (rowsContainer && rowsContainer.querySelectorAll) ? rowsContainer.querySelectorAll('.key') : document.querySelectorAll('.key');
      Array.from(keyButtons).forEach(btn => {
        try {
          const val = btn.dataset ? btn.dataset.value : null;
          btn.textContent = displayTextForKey(val);
        } catch (e) {}
      });
    } catch (e) { console.error('updateCapsUI error', e); }
  }

  function applyKeyboardProhibitMode() {
    try {
      const prohibit = !!(allowPhysical && allowPhysical.checked);
      if (!mainText) return;
      if (prohibit) {
        mainText.setAttribute('inputmode', 'none');
        mainText.readOnly = true;
        const blurOnFocus = (e) => { e.preventDefault(); mainText.blur(); };
        mainText.__blurOnFocus = blurOnFocus;
        try {
          mainText.addEventListener('focus', blurOnFocus, { passive: false });
        } catch(e) {
          try { mainText.addEventListener('focus', blurOnFocus, false); } catch(e){}
        }
        mainText.blur();
      } else {
        mainText.removeAttribute('inputmode');
        mainText.readOnly = false;
        if (mainText.__blurOnFocus) {
          try { mainText.removeEventListener('focus', mainText.__blurOnFocus); } catch(e){}
          delete mainText.__blurOnFocus;
        }
      }
      saveAll();
    } catch (e) { console.error('applyKeyboardProhibitMode error', e); }
  }

  try {
    if (allowPhysical) {
      allowPhysical.addEventListener('change', function () {
        try { applyKeyboardProhibitMode(); } catch (e) {}
      });
    }
  } catch (e) {}

  try {
    if (copyBtn) copyBtn.addEventListener('click', async function () {
      try {
        if (navigator.clipboard && mainText) {
          await navigator.clipboard.writeText(mainText.value);
          const prev = copyBtn.innerHTML;
          copyBtn.textContent = '✓';
          setTimeout(() => { copyBtn.innerHTML = prev; }, 900);
        } else if (mainText) {
          mainText.select();
          document.execCommand('copy');
        }
      } catch (e) {
        console.error('copy failed', e);
      }
    }, { passive: true });
  } catch (e) {}

  try {
    if (backspaceBtn) backspaceBtn.addEventListener('click', function () {
      try {
        const ta = mainText;
        if (!ta) return;
        const prohibit = !!(allowPhysical && allowPhysical.checked);
        const start = (typeof ta.selectionStart === 'number') ? ta.selectionStart : ta.value.length;
        const end = (typeof ta.selectionEnd === 'number') ? ta.selectionEnd : start;
        if (prohibit) ta.readOnly = false;
        if (start === end) {
          if (start > 0) {
            const newPos = start - 1;
            ta.value = ta.value.slice(0, newPos) + ta.value.slice(end);
            try { setSelectionSafe(ta, newPos, newPos); } catch (e) {}
          }
        } else {
          ta.value = ta.value.slice(0, start) + ta.value.slice(end);
          try { setSelectionSafe(ta, start, start); } catch (e) {}
        }
        ta.dispatchEvent(new Event('input', { bubbles: true }));
        ta.dispatchEvent(new Event('change', { bubbles: true }));
        if (prohibit) ta.readOnly = true;
      } catch (e) { console.error('backspace handler error', e); }
    }, { passive: true });
  } catch (e) {}

  try {
    if (spaceBtn) spaceBtn.addEventListener('click', function () {
      try { insertAtCursor(' '); } catch (e) {}
    }, { passive: true });
  } catch (e) {}

  try {
    (function setupCapsButton() {
      if (!capsBtn) return;
      const DOUBLE_TAP_MS = 350;
      const LONGPRESS_MS  = 500;
      let lastUpTime = 0;
      let singleTapTimer = null;
      let longpressTimer = null;
      function clearSingle() { if (singleTapTimer) { clearTimeout(singleTapTimer); singleTapTimer = null; } }
      function clearLong() { if (longpressTimer) { clearTimeout(longpressTimer); longpressTimer = null; } }
      function doSingle() {
        if (capsState === 2) {
          capsState = 0;
        } else if (capsState === 0) {
          capsState = 1;
        } else if (capsState === 1) {
          capsState = 0;
        }
        updateCapsUI();
        saveAll();
      }
      function doLock() {
        capsState = 2;
        updateCapsUI();
        saveAll();
      }
      addPointerListeners(capsBtn, 'down', (ev) => {
        clearLong();
        longpressTimer = setTimeout(() => {
          doLock();
          clearSingle();
        }, LONGPRESS_MS);
      }, { passive: true });
      addPointerListeners(capsBtn, 'up', (ev) => {
        clearLong();
        const now = Date.now();
        if (now - lastUpTime <= DOUBLE_TAP_MS) {
          clearSingle();
          doLock();
          lastUpTime = 0;
          return;
        }
        lastUpTime = now;
        clearSingle();
        singleTapTimer = setTimeout(() => {
          doSingle();
          singleTapTimer = null;
          lastUpTime = 0;
        }, Math.min(200, DOUBLE_TAP_MS));
      }, { passive: true });
      try {
        capsBtn.addEventListener('dblclick', function (e) {
          e.preventDefault && e.preventDefault();
          clearSingle();
          clearLong();
          doLock();
        }, { passive: true });
      } catch (e) {}
    })();

  } catch (e) {}

  try {
    function jumpToRow(n) {
      try {
        const idx = Math.max(0, n - 1);
        if (!rowsContainer) return;
        const rowEl = rowsContainer.children[idx];
        if (!rowEl) return;
        const top = rowEl.offsetTop - rowsContainer.offsetTop;
        smoothScrollTo(rowsContainer, top);
      } catch (e) {}
    }
    document.querySelectorAll('.jumpBtn').forEach(btn => {
      try {
        btn.addEventListener('click', () => {
          try {
            const n = parseInt(btn.dataset.row, 10);
            jumpToRow(n);
          } catch (e) {}
        }, { passive: true });
      } catch (e) {}
    });
  } catch (e) {}

  try {
    if (rowsContainer) rowsContainer.addEventListener('touchmove', function(e){ }, { passive: true });
  } catch (e) {}

  try {
    loadAll();
    applyKeyboardProhibitMode();
    render();
  } catch (e) {
    console.error('init error', e);
    try { render(); } catch (e2) { console.error('second render attempt failed', e2); }
  }

(function initThemeToggleButton() {
  try {
    if (!themeToggle) return;

    themeToggle.addEventListener("click", () => {
      darkOn = !darkOn;
      applyTheme();
      saveAll();
    });
  } catch (err) {
    console.error("theme toggle error", err);
  }
})();

(function initSettings() {
  try {
    const settingsBtn = document.getElementById('settingsBtn');
    const settingsPopup = document.getElementById('settingsPopup');
    const langSelect = document.getElementById('langSelect');

    settingsBtn && settingsBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      settingsPopup.classList.toggle('hidden');
      settingsPopup.setAttribute('aria-hidden', settingsPopup.classList.contains('hidden') ? 'true' : 'false');
    });

    document.addEventListener('click', (e) => {
      if (!settingsPopup || !settingsBtn) return;
      if (!settingsPopup.contains(e.target) && !settingsBtn.contains(e.target)) {
        settingsPopup.classList.add('hidden');
        settingsPopup.setAttribute('aria-hidden', 'true');
      }
    });

    function setLayoutByKey(key) {
      if (key === 'default') {
        currentLayout = null;
      } else if (key === 'ru') {
        currentLayout = [
          ['й','ц','у','к','е','н','г','ш','щ','з','х','ъ'],
          ['ф','ы','в','а','п','р','о','л','д','ж','э'],
          ['я','ч','с','м','и','т','ь','б','ю','.']
        ];
      } else if (key === 'en') {
        currentLayout = [
          ['a','b','c','d','e','f','g','h','i','j'],
          ['k','l','m','n','o','p','q','r','s','t'],
          ['u','v','w','x','y','z']
        ];
      } else if (key === 'sa') {
        currentLayout = [
  ['अ','आ','इ','ई','उ','ऊ'],
  ['ऋ','ॠ','ऌ','ॡ','ए','ऐ'],
  ['ओ','औ'],
  ['क','ख','ग','घ','ङ','च'],
  ['ड','ढ','ण','त','थ','द'],
  ['ध','न','प','फ','ब','भ'],
  ['म','य','र','ल','ळ','ऴ'],
  ['व','श','ष','स','ह','क्ष'],
  ['त्र','ज्ञ'],
  [' ो',' ौ',' ः',' ं'],        
  [' ृ',' ॄ',' ॢ',' ॣ',' े',' ै'],
  ['्','ा',' ि',' ी',' ु',' ू'],
  ['०','१','२','३','४','५'],
  ['६','७','८','९'],
  ['।','॥']

        ];
      } else {
        currentLayout = null;
      }
      render();
      localStorage.setItem(STORAGE_LANG, key);
    }

    langSelect.addEventListener('change', (e) => {
      setLayoutByKey(e.target.value);
    });

    (function restoreSettings() {
      try {
        const savedLang = localStorage.getItem(STORAGE_LANG);
        if (savedLang) {
          langSelect.value = savedLang;
          setLayoutByKey(savedLang);
        } else {

        }
      } catch (e) {}
    })();

  } catch (err) {
    console.error('initSettings error', err);
  }
})();

})();
</script>

</body>
</html>

